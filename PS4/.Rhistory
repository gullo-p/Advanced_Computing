start.time <- Sys.time()
a <- kNN(dataset[,1:2], dataset[,4], k = 1, p= 2, type = "train")
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
a$predLabels
a$prob
table(a$predLabels, dataset$label)
a <- kNN(dataset[,1:2], dataset[,4], k = 1, p= 2, type = "train")
dataset <- genGaussMix()
start.time <- Sys.time()
a <- kNN(dataset[,1:2], dataset[,4], k = 1, p= 2, type = "train")
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
a <- kNN(dataset[,1:2], dataset[,4], k = 1, p= 2, type = "train", control = FALSE)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
a$predLabels
a$prob
a <- kNN(dataset[,1:2], dataset[,4], k = 1, p= 2, type = "train", control = FALSE)
library(mvtnorm)
library(dplyr)
library(plyr)
#Function for the KNN.
#Remark: control is a dummy, which is set to TRUE if distMatrix has already been created,
#so that in future calls of the function (important when optimizing over k) it won't be calculated again.
kNN <- function(features, labels, memory,
k, p, type, control) {
# test the inputs
library(assertthat)
not_empty(features); not_empty(labels);
if (type == "train") {
assert_that(nrow(features) == length(labels))
}
is.string(type); assert_that(type %in% c("train", "predict"))
is.count(k);
assert_that(p %in% c(1: 100, Inf))
if (type == "predict") {
assert_that(not_empty(memory) &
ncol(memory) == ncol(features) &
nrow(memory) == length(labels))
}
# Compute the distance between each point and all others
noObs <- nrow(features)
if(control == FALSE){
# if we are making predictions on the test set based on the memory,
# we compute distances between each test observation and observations
# in our memory
if (type == "train") {
distMatrix <- matrix(NA, noObs, noObs)
for (obs in 1:noObs) {
# getting the probe for the current observation
probe <- as.numeric(features[obs,])
robeExpanded <- matrix(probe, nrow = noObs, ncol = ncol(features),
byrow = TRUE)
# computing distances between the probe and exemplars in the
# training X
if (p != Inf) {
distMatrix[obs, ] <- (rowSums((abs(features -
probeExpanded))^p) )^(1/p)
} else {
distMatrix[obs, ] <- apply(abs(features - probeExpanded), 1, max)
}
}
} else if (type == "predict") {
noMemory <- nrow(memory)
distMatrix <- matrix(NA, noObs, noMemory)
for (obs in 1:noObs) {
# getting the probe for the current observation
probe <- as.numeric(features[obs,])
probeExpanded <- matrix(probe, nrow = noMemory, ncol = ncol(memory),
byrow = TRUE)
# computing distances between the probe and exemplars in the memory
if (p != Inf) {
distMatrix[obs, ] <- (rowSums((abs(memory -
probeExpanded))^p) )^(1/p)
} else {
distMatrix[obs, ] <- apply(abs(memory - probeExpanded), 1, max)
}
}
}
# Sort the distances in increasing numerical order and pick the first
# k elements
neighbors <- apply(distMatrix, 1, order)
#update the value of control
control <- TRUE
}
# Compute the frequency of the assigned class in the k nearest neighbors and return the vector of probabilities
prob <- rep(NA, nrow =noObs)
predLabels <- rep(NA, noObs)
for (obs in 1:noObs) {
# predicted label
x <- as.vector(labels[neighbors[1:k, obs]])
predLabels[obs] <- as.numeric(names(sort(-table(x)))[1]) #computes the mode of the labels of the k-nn
#frequency of the predicted label among the k-NN
prob[obs] <- max(count(labels[neighbors[1:k, obs]])$freq)/k
}
# return the results
return(list(predLabels = predLabels,
prob = prob,
distMatrix = distMatrix,
neighbors = neighbors,
control = control
))
}
genGaussMix <- function(noObs = c(100, 100),
noGaussians = 10,
mixtureProb = rep(1/noGaussians, noGaussians),
seed = 2222) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then
# generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1],
mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2],
mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>%
sapply(function(x) rmvnorm(1, mean = meansC1[x,],
sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>%
sapply(function(x) rmvnorm(1, mean = meansC2[x,],
sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2),
label = c(rep("C1", noObs[1]), rep("C2", noObs[2])),
y = c(rep(0, noObs[1]), rep(1, noObs[2])),
stringsAsFactors = FALSE)
return(dataset)
}
dataset <- genGaussMix()
start.time <- Sys.time()
a <- kNN(dataset[,1:2], dataset[,4], k = 1, p= 2, type = "train", control = FALSE)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
a$predLabels
a$prob
table(a$predLabels, dataset$label)
library(mvtnorm)
library(dplyr)
library(plyr)
#Function for the KNN.
#Remark: control is a dummy, which is set to TRUE if distMatrix has already been created,
#so that in future calls of the function (important when optimizing over k) it won't be calculated again.
kNN <- function(features, labels, memory,
k, p, type, control) {
# test the inputs
library(assertthat)
not_empty(features); not_empty(labels);
if (type == "train") {
assert_that(nrow(features) == length(labels))
}
is.string(type); assert_that(type %in% c("train", "predict"))
is.count(k);
assert_that(p %in% c(1: 100, Inf))
if (type == "predict") {
assert_that(not_empty(memory) &
ncol(memory) == ncol(features) &
nrow(memory) == length(labels))
}
# Compute the distance between each point and all others
noObs <- nrow(features)
if(control == FALSE){
# if we are making predictions on the test set based on the memory,
# we compute distances between each test observation and observations
# in our memory
if (type == "train") {
distMatrix <- matrix(NA, noObs, noObs)
for (obs in 1:noObs) {
# getting the probe for the current observation
probe <- as.numeric(features[obs,])
probeExpanded <- matrix(probe, nrow = noObs, ncol = ncol(features),
byrow = TRUE)
# computing distances between the probe and exemplars in the
# training X
if (p != Inf) {
distMatrix[obs, ] <- (rowSums((abs(features -
probeExpanded))^p) )^(1/p)
} else {
distMatrix[obs, ] <- apply(abs(features - probeExpanded), 1, max)
}
}
} else if (type == "predict") {
noMemory <- nrow(memory)
distMatrix <- matrix(NA, noObs, noMemory)
for (obs in 1:noObs) {
# getting the probe for the current observation
probe <- as.numeric(features[obs,])
probeExpanded <- matrix(probe, nrow = noMemory, ncol = ncol(memory),
byrow = TRUE)
# computing distances between the probe and exemplars in the memory
if (p != Inf) {
distMatrix[obs, ] <- (rowSums((abs(memory -
probeExpanded))^p) )^(1/p)
} else {
distMatrix[obs, ] <- apply(abs(memory - probeExpanded), 1, max)
}
}
}
# Sort the distances in increasing numerical order and pick the first
# k elements
neighbors <- apply(distMatrix, 1, order)
#update the value of control
control <- TRUE
}
# Compute the frequency of the assigned class in the k nearest neighbors and return the vector of probabilities
prob <- rep(NA, nrow =noObs)
predLabels <- rep(NA, noObs)
for (obs in 1:noObs) {
# predicted label
x <- as.vector(labels[neighbors[1:k, obs]])
predLabels[obs] <- as.numeric(names(sort(-table(x)))[1]) #computes the mode of the labels of the k-nn
#frequency of the predicted label among the k-NN
prob[obs] <- max(count(labels[neighbors[1:k, obs]])$freq)/k
}
# return the results
return(list(predLabels = predLabels,
prob = prob,
distMatrix = distMatrix,
neighbors = neighbors,
control = control
))
}
genGaussMix <- function(noObs = c(100, 100),
noGaussians = 10,
mixtureProb = rep(1/noGaussians, noGaussians),
seed = 2222) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then
# generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1],
mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2],
mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>%
sapply(function(x) rmvnorm(1, mean = meansC1[x,],
sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>%
sapply(function(x) rmvnorm(1, mean = meansC2[x,],
sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2),
label = c(rep("C1", noObs[1]), rep("C2", noObs[2])),
y = c(rep(0, noObs[1]), rep(1, noObs[2])),
stringsAsFactors = FALSE)
return(dataset)
}
dataset <- genGaussMix()
start.time <- Sys.time()
a <- kNN(dataset[,1:2], dataset[,4], k = 1, p= 2, type = "train", control = FALSE)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
a$predLabels
a$prob
setwd("/Users/guglielmo/Desktop/BGSE/winter_term/Adv_Computing/Advanced_Computing/PS4") #change the path to the directory PS4 of the github repo
source("kNN.R")
# ----
# Denitsa's spirals
# ----
genSpirals <- function(N = 200,
degrees = 570,
location = 90,
blend = 0.2,
saveData = FALSE,
savePlot = FALSE) {
# Generate two-spiral data
# idea of the problematic dataset: http://www.benmargolis.com/compsci/ai/two_spirals_problem.htm
# N - number of observations
# degrees - length of the spiral
# location - how far away from the origin
# blend<-blending together
#necessary packages
if (!require("ggplot2")) install.packages("ggplot2"); library(ggplot2)
# define some variables
degrees2rad <- (2*pi)/360 #convert degrees to radiant
location <- location*degrees2rad #how far away from 00 the spiral starts
N1 <- floor(N/2)
N2 <- N-N1
#spiral 1
#we indicate it by 0 in V3
n <- as.vector(location+sqrt(runif(N1))*degrees*degrees2rad)
d1 <- t(rbind(-1*n*cos(n)+runif(N1)*blend, sin(n)*n+runif(N1)*blend, rep(0,N1)))
#the second spiral we indicate by 1 in V3
n <- as.vector(location+sqrt(runif(N1))*degrees*degrees2rad)
d2 <-t(rbind(n*cos(n)+runif(N1)*blend, -1*sin(n)*n+runif(N1)*blend, rep(1,N1)))
#combine the data
data <- data.frame(rbind(d1, d2))
names(data) <- c("x1", "x2", "y")
return(data)
}
#create the data to test
data <- genSpirals()
#call the kNN function and get predLabels and prob
a <- kNN(dataset[,1:2], dataset[,4], data[,1:2], k = 5, p = 2, type = "predict")
realdata <- cbind(data, a$predLabels, a$prob)
#save in the right format in a csv file
colnames(realdata) <- c("X1", "X2", "Y", "predLabels","prob")
write.csv(realdata, "predictions.csv", row.names = FALSE)
#save the pdf file
cairo_pdf("dataPlot.pdf")
print(
ggplot(data = realdata,
aes(x = x1, y = x2, colour=y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
stat_contour(mapping = predLabels, data = realdata)+
theme_bw()
)
dev.off()
setwd("/Users/guglielmo/Desktop/BGSE/winter_term/Adv_Computing/Advanced_Computing/PS4") #change the path to the directory PS4 of the github repo
source("kNN.R")
# ----
# Denitsa's spirals
# ----
genSpirals <- function(N = 200,
degrees = 570,
location = 90,
blend = 0.2,
saveData = FALSE,
savePlot = FALSE) {
# Generate two-spiral data
# idea of the problematic dataset: http://www.benmargolis.com/compsci/ai/two_spirals_problem.htm
# N - number of observations
# degrees - length of the spiral
# location - how far away from the origin
# blend<-blending together
#necessary packages
if (!require("ggplot2")) install.packages("ggplot2"); library(ggplot2)
# define some variables
degrees2rad <- (2*pi)/360 #convert degrees to radiant
location <- location*degrees2rad #how far away from 00 the spiral starts
N1 <- floor(N/2)
N2 <- N-N1
#spiral 1
#we indicate it by 0 in V3
n <- as.vector(location+sqrt(runif(N1))*degrees*degrees2rad)
d1 <- t(rbind(-1*n*cos(n)+runif(N1)*blend, sin(n)*n+runif(N1)*blend, rep(0,N1)))
#the second spiral we indicate by 1 in V3
n <- as.vector(location+sqrt(runif(N1))*degrees*degrees2rad)
d2 <-t(rbind(n*cos(n)+runif(N1)*blend, -1*sin(n)*n+runif(N1)*blend, rep(1,N1)))
#combine the data
data <- data.frame(rbind(d1, d2))
names(data) <- c("x1", "x2", "y")
return(data)
}
#create the data to test
data <- genSpirals()
#call the kNN function and get predLabels and prob
a <- kNN(dataset[,1:2], dataset[,4], data[,1:2], k = 5, p = 2, type = "predict")
realdata <- cbind(data, a$predLabels, a$prob)
#save in the right format in a csv file
colnames(realdata) <- c("X1", "X2", "Y", "predLabels","prob")
write.csv(realdata, "predictions.csv", row.names = FALSE)
#save the pdf file
cairo_pdf("dataPlot.pdf")
print(
ggplot(data = realdata,
aes(x = x1, y = x2, colour=y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
#stat_contour(mapping = predLabels, data = realdata)+
theme_bw()
)
dev.off()
setwd("/Users/guglielmo/Desktop/BGSE/winter_term/Adv_Computing/Advanced_Computing/PS4") #change the path to the directory PS4 of the github repo
source("kNN.R")
# ----
# Denitsa's spirals
# ----
genSpirals <- function(N = 200,
degrees = 570,
location = 90,
blend = 0.2,
saveData = FALSE,
savePlot = FALSE) {
# Generate two-spiral data
# idea of the problematic dataset: http://www.benmargolis.com/compsci/ai/two_spirals_problem.htm
# N - number of observations
# degrees - length of the spiral
# location - how far away from the origin
# blend<-blending together
#necessary packages
if (!require("ggplot2")) install.packages("ggplot2"); library(ggplot2)
# define some variables
degrees2rad <- (2*pi)/360 #convert degrees to radiant
location <- location*degrees2rad #how far away from 00 the spiral starts
N1 <- floor(N/2)
N2 <- N-N1
#spiral 1
#we indicate it by 0 in V3
n <- as.vector(location+sqrt(runif(N1))*degrees*degrees2rad)
d1 <- t(rbind(-1*n*cos(n)+runif(N1)*blend, sin(n)*n+runif(N1)*blend, rep(0,N1)))
#the second spiral we indicate by 1 in V3
n <- as.vector(location+sqrt(runif(N1))*degrees*degrees2rad)
d2 <-t(rbind(n*cos(n)+runif(N1)*blend, -1*sin(n)*n+runif(N1)*blend, rep(1,N1)))
#combine the data
data <- data.frame(rbind(d1, d2))
names(data) <- c("x1", "x2", "y")
return(data)
}
#create the data to test
data <- genSpirals()
#call the kNN function and get predLabels and prob
a <- kNN(dataset[,1:2], dataset[,4], data[,1:2], k = 5, p = 2, type = "predict")
realdata <- cbind(data, a$predLabels, a$prob)
#save in the right format in a csv file
colnames(realdata) <- c("X1", "X2", "Y", "predLabels","prob")
write.csv(realdata, "predictions.csv", row.names = FALSE)
#save the pdf file
cairo_pdf("dataPlot.pdf")
print(
ggplot(data = realdata,
aes(x = X1, y = X2, colour=Y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
#stat_contour(mapping = predLabels, data = realdata)+
theme_bw()
)
dev.off()
#save the pdf file
cairo_pdf("dataPlot.pdf")
print(
ggplot(data = realdata,
aes(x = X1, y = X2, colour=Y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
theme_bw()
)
dev.off()
a <- kNN(dataset[,1:2], dataset[,4], data[,1:2], k = 5, p = 2, type = "predict", control = FALSE)
realdata <- cbind(data, a$predLabels, a$prob)
#save in the right format in a csv file
colnames(realdata) <- c("X1", "X2", "Y", "predLabels","prob")
write.csv(realdata, "predictions.csv", row.names = FALSE)
#save the pdf file
cairo_pdf("dataPlot.pdf")
print(
ggplot(data = realdata,
aes(x = X1, y = X2, colour=Y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
theme_bw()
)
dev.off()
pdf("dataPlot.pdf")
print(
ggplot(data = realdata,
aes(x = X1, y = X2, colour=Y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
theme_bw()
)
dev.off()
plot.pdf <- function(realdata){
pdf("dataPlot.pdf", width=4, height=4.5)
a <- ggplot(data = realdata,
aes(x = X1, y = X2, colour=Y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
theme_bw()
print(a)
dev.off()
}
plot.pdf(realdata)
setwd("~/Desktop/BGSE/winter_term/Adv_Computing/Advanced_Computing/PS4")
plot.pdf <- function(realdata){
pdf("dataPlot.pdf", width=4, height=4.5)
a <- ggplot(data = realdata,
aes(x = X1, y = X2, colour=Y)) +
scale_colour_continuous(guide = FALSE) +
geom_point() +
ggtitle("Spirals") +
xlab("x1") +
ylab("x2") +
theme_bw()
print(a)
dev.off()
}
plot.pdf(realdata)
